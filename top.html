<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <title>Ø£Ø¨Ø·Ø§Ù„ Ø§Ù„Ø¹Ù…Ù„ÙŠØ§Øª Ø§Ù„Ø­Ø³Ø§Ø¨ÙŠØ© (ØªØ®ØµÙŠØµ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¹Ù…Ù„ÙŠØ§Øª) Ø¨Ø§Ù„Ø£Ø±Ù‚Ø§Ù… Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©</title>
    <style>
        /* Ø§Ù„Ø£Ù†Ù…Ø§Ø· (CSS) */
        body { font-family: 'Arial', sans-serif; text-align: center; margin-top: 30px; background-color: #f4f4f9; }
        
        .main-content { 
            display: flex; 
            justify-content: center;
            max-width: 1000px;
            margin: auto; 
        }
        .container { 
            width: 100%;
            padding: 20px; 
            border: 5px solid #007BFF;
            border-radius: 15px; 
            background-color: #fff;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }
        
        h1 { color: #007BFF; margin-bottom: 20px; }
        
        /* Ù‚Ø³Ù… Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„Ø£Ø³Ù…Ø§Ø¡ ÙˆØ§Ù„Ù…Ø¬Ù„Ø¯Ø§Øª */
        .names-input-section { margin-bottom: 20px; padding: 15px; border: 1px dashed #ccc; border-radius: 8px; display: flex; justify-content: space-between; gap: 10px; }
        .folder { width: 33%; text-align: right; }
        .folder-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px; }
        .folder label { font-weight: bold; color: #dc3545; display: inline-block; }
        
        /* ğŸŒŸ Ù†Ù…Ø· Ø­Ù‚Ù„ Ø§Ù„Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„Ù…ØªØ¹Ø¯Ø¯ */
        .folder textarea { width: 100%; resize: vertical; margin-bottom: 5px; box-sizing: border-box; }
        .folder button { 
             width: 100%;
             background-color: #007BFF; 
             color: white; 
             border: none; 
             padding: 5px 10px; 
             cursor: pointer; 
             border-radius: 3px;
             margin-bottom: 10px;
        }

        /* ğŸŒŸ Ù†Ù…Ø· Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…ØªØ³Ø§Ø¨Ù‚ÙŠÙ† Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© */
        .contestants-list {
            margin-top: 5px;
            height: 120px;
            overflow-y: scroll;
            -webkit-overflow-scrolling: touch; 
            -ms-overflow-style: -ms-autohiding-scrollbar; 
            
            border: 1px solid #007BFF;
            border-radius: 4px;
            padding: 5px;
            text-align: right;
            box-sizing: border-box;
            background-color: #f8faff;
        }
        .contestant-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 3px 0;
            border-bottom: 1px dotted #ccc;
        }
        .contestant-item:last-child {
            border-bottom: none;
        }
        .contestant-item input[type="checkbox"] {
            margin-left: 10px; 
        }
        .contestant-item button {
             background: none;
             border: none;
             cursor: pointer;
             font-size: 0.9em;
             color: #dc3545;
             padding: 0; 
             width: auto; 
        }

        /* Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø¬ÙˆÙ„Ø© */
        .round-setup { margin-bottom: 20px; padding: 15px; background-color: #e9ecef; border-radius: 8px; display: flex; flex-wrap: wrap; justify-content: center; align-items: center; gap: 15px; }
        .round-setup label { font-weight: bold; }
        .round-setup select { padding: 8px; font-size: 1em; border-radius: 5px; border: 1px solid #FFC107; }
        
        /* Ø¥Ø®ÙØ§Ø¡ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø¹Ù…Ù„ÙŠØ© ÙˆØ§Ù„Ù…Ø³ØªÙˆÙ‰ ÙÙŠ Ø¨Ø¹Ø¶ Ø§Ù„Ø£ÙˆØ¶Ø§Ø¹ */
        .op-level-control { 
            transition: opacity 0.5s; 
        }
        .hide-op-level .op-level-control {
            opacity: 0.2;
            pointer-events: none;
        }

        .header-section { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; border-bottom: 2px solid #eee; padding-bottom: 10px; }
        #turn-indicator { font-size: 1.5em; }
        #timer-display { font-size: 2em; font-weight: bold; color: #333; padding: 5px 15px; border: 3px dashed #FFC107; border-radius: 8px; min-width: 120px; }

        /* ØªØ¹Ø¯ÙŠÙ„Ø§Øª Ø§Ù„Ø³Ø¤Ø§Ù„ Ù„ÙŠØµØ¨Ø­ Ø¹Ù…ÙˆØ¯ÙŠÙ‹Ø§ */
        #question { 
            font-size: 3em; 
            margin: 30px auto; 
            color: #333; 
            min-height: 150px; 
            width: 350px; 
            text-align: right; 
        }
        .q-line {
            display: flex;
            justify-content: flex-end; 
            font-size: 1em;
            height: 1.2em;
            line-height: 1.2em;
            flex-wrap: wrap;
        }
        #q-num1, #q-num2 {
            min-width: 150px; 
            text-align: right;
            padding-right: 5px;
            white-space: nowrap; 
        }
        #q-op2 {
             min-width: 120px; 
             text-align: center;
             font-size: 0.8em; 
             font-weight: bold;
             padding-right: 5px;
        }
        #q-line-separator {
            border-bottom: 5px solid #000;
            margin: 5px 0 10px 0;
            width: 100%;
        }

        /* Ø­Ø§ÙˆÙŠØ© Ø®ÙŠØ§Ø±Ø§Øª Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© */
        #answer-options-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin: 20px auto;
            max-width: 600px;
        }

        /* Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© */
        .answer-btn { 
            background-color: #007BFF; 
            color: white; 
            padding: 15px 10px; 
            font-size: 1.5em; 
            border: none; 
            cursor: pointer; 
            border-radius: 8px; 
            transition: background-color 0.3s, transform 0.1s; 
            box-shadow: 0 4px #0056b3; 
            min-height: 60px;
        }
        .answer-btn:hover:not(:disabled) { 
            background-color: #0056b3; 
            transform: translateY(2px);
            box-shadow: 0 2px #004085;
        }
        .answer-btn:disabled { 
            cursor: not-allowed; 
            opacity: 0.6;
            box-shadow: none;
        }
        .correct-answer { background-color: #28a745 !important; box-shadow: 0 4px #1e7e34 !important; }
        .wrong-answer { background-color: #dc3545 !important; box-shadow: 0 4px #a71d2a !important; }

        /* Ø§Ù„Ø£Ù†Ù…Ø§Ø· Ø§Ù„Ø£Ø®Ø±Ù‰ */
        .controls { display: flex; justify-content: center; gap: 10px; margin-top: 10px; }
        #start-btn, #next-round-btn { padding: 12px 25px; font-size: 1.4em; color: white; border: none; cursor: pointer; border-radius: 8px; transition: background-color 0.3s; }
        #start-btn { background-color: #28a745; }
        #next-round-btn { background-color: #007BFF; display: none; } 

        /* Ù†Ù…Ø· Ù„Ù„ØªØºØ°ÙŠØ© Ø§Ù„Ø±Ø§Ø¬Ø¹Ø© */
        .correct { color: #28a745; font-weight: bold; }
        .wrong { color: #dc3545; font-weight: bold; }
        
        /* ğŸŒŸ ØªÙ†Ø³ÙŠÙ‚ Ù‚Ø³Ù… Ø§Ù„Ù…ØªØ³Ø§Ø¨Ù‚ÙŠÙ† Ø§Ù„Ù…ØªØ¨Ù‚ÙŠÙ† */
        .remaining-contestants-section {
            margin-top: 30px;
            padding: 15px;
            border: 1px solid #007BFF;
            border-radius: 10px;
            background-color: #e3f2fd; 
            max-width: 1000px;
            margin-left: auto;
            margin-right: auto;
            text-align: right;
        }
        .remaining-contestants-section h2 {
            color: #0056b3;
            border-bottom: 2px dashed #a0c4ff;
            padding-bottom: 5px;
            margin-bottom: 10px;
            font-size: 1.3em;
        }
        #remaining-contestants-display {
            font-size: 1.1em;
            font-weight: bold;
            color: #333;
            line-height: 1.6;
        }
        
        /* ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„ØªØ°ÙŠÙŠÙ„ */
        .footer-text {
            margin-top: 40px;
            padding: 10px 0;
            font-size: 1.1em;
            color: #555;
            text-align: center;
            border-top: 1px solid #ccc;
            max-width: 1000px;
            margin-left: auto;
            margin-right: auto;
        }

        /* ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„Ø¬ÙˆØ§Ù„ ÙÙŠ Ø§Ù„ÙˆØ¶Ø¹ Ø§Ù„Ø£ÙÙ‚ÙŠ */
        @media screen and (max-width: 1024px) and (orientation: landscape) {
            .main-content {
                max-width: 100%;
                padding: 10px;
            }
            
            .container {
                padding: 15px;
                width: 100%;
            }
            
            /* Ø¬Ø¹Ù„ Ø§Ù„Ø£Ø¬ÙˆØ¨Ø© ÙÙŠ ØµÙ ÙˆØ§Ø­Ø¯ */
            #answer-options-container {
                grid-template-columns: 1fr 1fr 1fr 1fr;
                gap: 10px;
                max-width: 100%;
                margin: 15px auto;
            }
            
            .answer-btn {
                font-size: 1.2em;
                padding: 12px 8px;
                min-height: 55px;
            }
            
            /* ØªØ¹Ø¯ÙŠÙ„ Ø­Ø¬Ù… Ø§Ù„Ø³Ø¤Ø§Ù„ */
            #question {
                font-size: 2.5em;
                margin: 20px auto;
                min-height: 130px;
                width: 300px;
            }
            
            .q-line {
                font-size: 0.9em;
                height: 1.1em;
                line-height: 1.1em;
            }
            
            /* ØªØ¹Ø¯ÙŠÙ„ Ù‚Ø³Ù… Ø§Ù„Ø£Ø³Ù…Ø§Ø¡ Ù„ÙŠÙƒÙˆÙ† Ø¹Ù…ÙˆØ¯ÙŠØ§Ù‹ ÙÙŠ Ø§Ù„Ø´Ø§Ø´Ø§Øª Ø§Ù„ØµØºÙŠØ±Ø© */
            .names-input-section {
                flex-direction: column;
            }
            
            .folder {
                width: 100%;
                margin-bottom: 15px;
            }
            
            .folder:last-child {
                margin-bottom: 0;
            }
            
            /* ØªØ¹Ø¯ÙŠÙ„ Ù‚Ø³Ù… Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ø¬ÙˆÙ„Ø© */
            .round-setup {
                flex-direction: column;
                align-items: stretch;
                gap: 10px;
            }
            
            .round-setup > * {
                width: 100%;
            }
            
            .round-setup label, 
            .round-setup select {
                width: 100%;
                margin-bottom: 5px;
            }
            
            /* ØªØ¹Ø¯ÙŠÙ„ Ø­Ø¬Ù… Ø§Ù„Ø®Ø·ÙˆØ· */
            h1 {
                font-size: 1.8em;
                margin-bottom: 15px;
            }
            
            #timer-display {
                font-size: 1.5em;
                min-width: 110px;
                padding: 4px 12px;
            }
            
            #turn-indicator {
                font-size: 1.2em;
            }
            
            /* ØªØ¹Ø¯ÙŠÙ„ Ù‚Ø³Ù… Ø§Ù„Ù…ØªØ³Ø§Ø¨Ù‚ÙŠÙ† Ø§Ù„Ù…ØªØ¨Ù‚ÙŠÙ† */
            .remaining-contestants-section {
                padding: 10px;
                margin-top: 20px;
            }
            
            .remaining-contestants-section h2 {
                font-size: 1.1em;
            }
            
            #remaining-contestants-display {
                font-size: 1em;
            }
            
            /* ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø£Ø²Ø±Ø§Ø± */
            #start-btn, #next-round-btn {
                padding: 10px 20px;
                font-size: 1.2em;
            }
        }

        /* Ù„Ù„Ø´Ø§Ø´Ø§Øª Ø§Ù„Ø£ØµØºØ± Ø¬Ø¯Ø§Ù‹ ÙÙŠ Ø§Ù„ÙˆØ¶Ø¹ Ø§Ù„Ø£ÙÙ‚ÙŠ */
        @media screen and (max-width: 768px) and (orientation: landscape) {
            #answer-options-container {
                grid-template-columns: 1fr 1fr;
                gap: 8px;
            }
            
            .answer-btn {
                font-size: 1.1em;
                padding: 10px 6px;
                min-height: 50px;
            }
            
            #question {
                font-size: 2.2em;
                min-height: 110px;
                width: 280px;
            }
            
            h1 {
                font-size: 1.6em;
            }
        }
    </style>
</head>
<body>

<div class="main-content">
    <div class="container">
        <h1>Ø£Ø¨Ø·Ø§Ù„ Ø§Ù„Ø¹Ù…Ù„ÙŠØ§Øª Ø§Ù„Ø­Ø³Ø§Ø¨ÙŠØ©</h1>
        
        <div class="names-input-section" id="names-section">
            <div class="folder">
                <div class="folder-header">
                    <label for="folder-a-name-input">Ø§Ø³Ù… Ø§Ù„Ù…Ø¬Ù„Ø¯:</label>
                    <input type="text" id="folder-a-name-input" value="Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø© Ø£">
                </div>
                <textarea id="bulk-input-A" rows="4" placeholder="Ø£Ù„ØµÙ‚ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø£Ø³Ù…Ø§Ø¡ Ù‡Ù†Ø§ (ÙƒÙ„ Ø§Ø³Ù… ÙÙŠ Ø³Ø·Ø±)"></textarea>
                <button onclick="updateContestantsFromBulk('A')">ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ù…Ù† Ù‡Ù†Ø§</button>
                <hr>
                <div id="contestants-list-A" class="contestants-list">
                    </div>
            </div>
            <div class="folder">
                <div class="folder-header">
                    <label for="folder-b-name-input">Ø§Ø³Ù… Ø§Ù„Ù…Ø¬Ù„Ø¯:</label>
                    <input type="text" id="folder-b-name-input" value="Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø© Ø¨">
                </div>
                <textarea id="bulk-input-B" rows="4" placeholder="Ø£Ù„ØµÙ‚ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø£Ø³Ù…Ø§Ø¡ Ù‡Ù†Ø§ (ÙƒÙ„ Ø§Ø³Ù… ÙÙŠ Ø³Ø·Ø±)"></textarea>
                <button onclick="updateContestantsFromBulk('B')">ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ù…Ù† Ù‡Ù†Ø§</button>
                <hr>
                <div id="contestants-list-B" class="contestants-list">
                    </div>
            </div>
            <div class="folder">
                <div class="folder-header">
                    <label for="folder-c-name-input">Ø§Ø³Ù… Ø§Ù„Ù…Ø¬Ù„Ø¯:</label>
                    <input type="text" id="folder-c-name-input" value="Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø© Ø¬">
                </div>
                <textarea id="bulk-input-C" rows="4" placeholder="Ø£Ù„ØµÙ‚ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø£Ø³Ù…Ø§Ø¡ Ù‡Ù†Ø§ (ÙƒÙ„ Ø§Ø³Ù… ÙÙŠ Ø³Ø·Ø±)"></textarea>
                <button onclick="updateContestantsFromBulk('C')">ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ù…Ù† Ù‡Ù†Ø§</button>
                <hr>
                <div id="contestants-list-C" class="contestants-list">
                    </div>
            </div>
        </div>

        <div class="round-setup" id="round-setup">
            <label for="folder-select">Ø§Ø®ØªØ± Ù…Ø¬Ù„Ø¯ Ø§Ù„Ù…Ù†Ø§ÙØ³Ø©:</label>
            <select id="folder-select">
                <option value="A">Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø© Ø£</option>
                <option value="B">Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø© Ø¨</option>
                <option value="C">Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø© Ø¬</option>
            </select>
            
            <div class="op-level-control">
                <label for="operation-select">Ø§Ø®ØªØ± Ø§Ù„Ø¹Ù…Ù„ÙŠØ©:</label>
                <select id="operation-select">
                    <option value="+">Ø¬Ù…Ø¹</option>
                    <option value="-">Ø·Ø±Ø­</option>
                    <option value="*">Ø¶Ø±Ø¨</option>
                    <option value="/">Ù‚Ø³Ù…Ø©</option>
                    <option value="R">ØªÙ‚Ø±ÙŠØ¨</option> 
                </select>
            </div>
            
            <div class="op-level-control">
                <label for="level-select">Ø§Ø®ØªØ± Ø§Ù„Ù…Ø³ØªÙˆÙ‰:</label>
                <select id="level-select">
                    <option value="1">Ø§Ù„Ù…Ø³ØªÙˆÙ‰ 1</option>
                    <option value="2">Ø§Ù„Ù…Ø³ØªÙˆÙ‰ 2</option>
                    <option value="3">Ø§Ù„Ù…Ø³ØªÙˆÙ‰ 3</option>
                    <option value="4">Ø§Ù„Ù…Ø³ØªÙˆÙ‰ 4</option>
                    <option value="5">Ø§Ù„Ù…Ø³ØªÙˆÙ‰ 5</option>
                </select>
            </div>
            
            <label for="mode-select">Ø§Ø®ØªØ± ÙˆØ¶Ø¹ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø©:</label>
            <select id="mode-select" onchange="toggleOpLevelControls()">
                <option value="elimination4">Ù…Ø³Ø§Ø¨Ù‚Ø© ØµÙ Ø«Ø§Ù„Ø« (ØªØµØ§Ø¹Ø¯ÙŠ Ø´Ø§Ù…Ù„ - Ø­Ø¯ Ø£Ù‚ØµÙ‰ 3)</option>
                <option value="elimination5">Ù…Ø³Ø§Ø¨Ù‚Ø© ØµÙ Ø±Ø§Ø¨Ø¹ (ØªØµØ§Ø¹Ø¯ÙŠ Ø´Ø§Ù…Ù„ - Ø­Ø¯ Ø£Ù‚ØµÙ‰ 4)</option>
                <option value="elimination3">Ù…Ø³Ø§Ø¨Ù‚Ø© ØµÙ Ø®Ø§Ù…Ø³ ÙØ£Ø¹Ù„Ù‰ (ØªØµØ§Ø¹Ø¯ÙŠ Ø´Ø§Ù…Ù„ - Ø­Ø¯ Ø£Ù‚ØµÙ‰ 5)</option>
                <option value="elimination1">Ù…Ø³Ø§Ø¨Ù‚Ø© Ø¹Ø§Ù…Ø© (Ù‚Ø³Ù… ÙˆÙ…Ø³ØªÙˆÙ‰ Ø«Ø§Ø¨Øª)</option>
                <option value="elimination2">Ù…Ø³Ø§Ø¨Ù‚Ø© Ø¹Ø§Ù…Ø© (Ù‚Ø³Ù… Ø«Ø§Ø¨Øª ÙˆÙ…Ø³ØªÙˆÙ‰ ØªØµØ§Ø¹Ø¯ÙŠ)</option>
            </select>
            
            <button id="start-btn" onclick="startGame()">Ø¨Ø¯Ø¡ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø©</button> 
            <button id="next-round-btn" onclick="startNewRound()" style="display: none;">Ø¬ÙˆÙ„Ø© Ø¬Ø¯ÙŠØ¯Ø©</button>
        </div>

        <div class="header-section">
            <div id="turn-indicator">
                Ø§Ù„Ø¯ÙˆØ±: <span id="current-player" class="player-turn">Ø£Ø¯Ø®Ù„ Ø§Ù„Ø£Ø³Ù…Ø§Ø¡</span>
            </div>
            <div id="timer-display">30 Ø«ÙˆØ§Ù†Ù</div> 
        </div>

        <div id="question">
             <div class="q-line" id="q-line-1">
                 <span id="q-op"></span>
                 <span id="q-num1">Ø§Ø¶ØºØ· Ø¨Ø¯Ø¡ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø©</span>
             </div>
             <div class="q-line" id="q-line-2">
                 <span id="q-op2"></span>
                 <span id="q-num2"></span>
             </div>
             <div id="q-line-separator"></div>
        </div> 
        
        <div id="answer-options-container">
            </div>

        <div id="feedback"></div>

        <div class="score-boards">
            <div id="score1-display" class="score">Ø§Ù„Ù…ØªØ³Ø§Ø¨Ù‚ 1: 0</div>
            <div id="score2-display" class="score">Ø§Ù„Ù…ØªØ³Ø§Ø¨Ù‚ 2: 0</div>
        </div>
    </div>
    
</div>

<div class="remaining-contestants-section">
    <h2>Ø§Ù„Ù…ØªØ³Ø§Ø¨Ù‚ÙˆÙ† Ø§Ù„Ø°ÙŠÙ† Ù…Ø§ Ø²Ø§Ù„ÙˆØ§ ÙÙŠ Ø§Ù„Ù…Ù†Ø§ÙØ³Ø©</h2>
    <p id="remaining-contestants-display" dir="rtl">Ø§Ø¶ØºØ· "Ø¬ÙˆÙ„Ø© Ø¥Ù‚ØµØ§Ø¡ Ø¬Ø¯ÙŠØ¯Ø©" Ù„Ø¹Ø±Ø¶ Ø§Ù„Ù…ØªØ³Ø§Ø¨Ù‚ÙŠÙ† Ø§Ù„Ù…ØªØ¨Ù‚ÙŠÙ†...</p>
</div>

<p class="footer-text" dir="rtl">Ø¥Ø¹Ø¯Ø§Ø¯: Ø§Ù„Ø£Ø³ØªØ§Ø° Ø¹Ø¨Ø¯Ø§Ù„Ø¹Ø²ÙŠØ² Ø§Ù„Ø­Ø¬ÙŠÙ„ÙŠ</p>

<script>
    let num1, num2, correctAnswerValue; 
    let correctAnswerDisplay; 
    let score1 = 0; 
    let score2 = 0; 
    let currentPlayer = 1; 
    let isProcessing = false;
    let gameStarted = false; 

    let playerName1 = "Ø§Ù„Ù…ØªØ³Ø§Ø¨Ù‚ 1";
    let playerName2 = "Ø§Ù„Ù…ØªØ³Ø§Ø¨Ù‚ 2";
    let currentFolderKey = ''; 
    
    let allStudentsByFolder = { A: [], B: [], C: [] }; 
    let folderNames = { A: "Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø© Ø£", B: "Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø© Ø¨", C: "Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø© Ø¬" }; 
    let globalScores = {}; 
    let currentRoundingDecimals = 0; 
    let currentRoundingPlace = ''; 

    const TIME_LIMIT = 30; 
    let timeRemaining = TIME_LIMIT;
    let timerInterval;

    const ARABIC_LOCALE = 'ar-SA'; 
    
    // --- Ù…ØªØºÙŠØ±Ø§Øª Ø®Ø±ÙˆØ¬ Ø§Ù„Ù…ØºÙ„ÙˆØ¨ ---
    let currentMode = 'elimination1';
    const MAX_ELIMINATION_QUESTIONS = 2; 
    let eliminationQuestionsCount = 0; 
    let player1Wins = 0;
    let player2Wins = 0;
    let folderStudentsInPlay = []; 
    let isTieBreaker = false; 
    
    // --- Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„ØªØµØ§Ø¹Ø¯ (Elimination 2 & 3 & 4 & 5) ---
    let currentTournamentRound = 0; 
    let tournamentSchedule = []; 
    let fixedOperation = ''; 
    const ALL_OPERATIONS = ['+', '-', '*', '/', 'R']; 
    const MAX_LEVEL = 5; 
    
    // ----------------------------------------------------------------
    // --- Ø¯ÙˆØ§Ù„ Ø§Ù„ØªØ­ÙƒÙ… ÙÙŠ Ø§Ù„ÙˆØ§Ø¬Ù‡Ø© (Ø§Ù„Ø£Ø³Ù…Ø§Ø¡ ÙˆÙ…Ø±Ø¨Ø¹Ø§Øª Ø§Ù„Ø§Ø®ØªÙŠØ§Ø±) ---
    // ----------------------------------------------------------------

    function updateContestantsFromBulk(folderKey) {
        const textarea = document.getElementById(`bulk-input-${folderKey}`);
        if (!textarea) return;

        const newNames = textarea.value.split(/[\n,;]+/)
            .map(name => name.trim())
            .filter(name => name.length > 0);

        let currentContestants = allStudentsByFolder[folderKey] || [];
        let updatedContestants = [...currentContestants];
        let addedCount = 0;

        newNames.forEach(name => {
            const existing = updatedContestants.find(c => c.name === name);
            
            if (!existing) {
                updatedContestants.push({ name: name, selected: true });
                addedCount++;
            } else {
                existing.selected = true;
            }
        });

        allStudentsByFolder[folderKey] = updatedContestants;

        textarea.value = '';
        
        saveContestantsData();
        renderContestantsList(folderKey);
        
        alert(`ØªÙ…Øª Ø¥Ø¶Ø§ÙØ© ${addedCount.toLocaleString(ARABIC_LOCALE)} Ù…ØªØ³Ø§Ø¨Ù‚Ø§Ù‹ Ø¬Ø¯ÙŠØ¯Ø§Ù‹ Ø¥Ù„Ù‰ ${folderNames[folderKey]}.`);
    }

    function removeContestant(folderKey, name) {
        allStudentsByFolder[folderKey] = allStudentsByFolder[folderKey].filter(c => c.name !== name);
        saveContestantsData();
        renderContestantsList(folderKey);
    }

    function toggleContestantSelection(folderKey, name) {
        const contestant = allStudentsByFolder[folderKey].find(c => c.name === name);
        if (contestant) {
            contestant.selected = !contestant.selected;
            saveContestantsData(); 
        }
    }

    function renderContestantsList(folderKey) {
        const listContainer = document.getElementById(`contestants-list-${folderKey}`);
        if (!listContainer) return;
        listContainer.innerHTML = '';
        
        allStudentsByFolder[folderKey].forEach(contestant => {
            const item = document.createElement('div');
            item.className = 'contestant-item';
            
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.checked = contestant.selected;
            checkbox.onchange = () => toggleContestantSelection(folderKey, contestant.name);

            const nameSpan = document.createElement('span');
            nameSpan.textContent = contestant.name;
            
            const deleteBtn = document.createElement('button');
            deleteBtn.textContent = 'âŒ';
            deleteBtn.title = `Ø­Ø°Ù ${contestant.name}`;
            deleteBtn.onclick = () => removeContestant(folderKey, contestant.name);

            const leftSide = document.createElement('div');
            leftSide.style.display = 'flex';
            leftSide.style.alignItems = 'center';
            leftSide.appendChild(checkbox);
            leftSide.appendChild(nameSpan);

            item.appendChild(leftSide);
            item.appendChild(deleteBtn);
            listContainer.appendChild(item);
        });
    }

    function toggleOpLevelControls() {
        const mode = document.getElementById('mode-select').value;
        const roundSetup = document.getElementById('round-setup');
        
        if (mode === 'elimination1' || mode === 'elimination2') {
            roundSetup.classList.remove('hide-op-level');
        } 
        else if (mode === 'elimination3' || mode === 'elimination4' || mode === 'elimination5') {
            roundSetup.classList.add('hide-op-level');
        }
    }
    document.addEventListener('DOMContentLoaded', toggleOpLevelControls);

    function updateRemainingContestantsDisplay() {
        const displayElement = document.getElementById('remaining-contestants-display');
        const folderName = folderNames[currentFolderKey] || 'Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ©';
        
        if (folderStudentsInPlay.length === 0) {
            displayElement.innerHTML = `Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù…ØªØ³Ø§Ø¨Ù‚ÙˆÙ† Ù…ØªØ¨Ù‚ÙˆÙ† ÙÙŠ **${folderName}**. Ø§Ø¶ØºØ· "Ø¬ÙˆÙ„Ø© Ø¥Ù‚ØµØ§Ø¡ Ø¬Ø¯ÙŠØ¯Ø©" Ù„Ø¨Ø¯Ø¡ Ø¨Ø·ÙˆÙ„Ø© Ø¬Ø¯ÙŠØ¯Ø©.`;
        } else if (folderStudentsInPlay.length === 1) {
            const champion = folderStudentsInPlay[0];
            displayElement.innerHTML = `**Ø§Ù„Ø¨Ø·Ù„ Ø§Ù„Ø­Ø§Ù„ÙŠ:** ğŸ‘‘ ${champion} ğŸ‘‘. Ø§Ø¶ØºØ· "Ø¨Ø¯Ø¡ Ø¨Ø·ÙˆÙ„Ø© Ø¬Ø¯ÙŠØ¯Ø©" Ù„Ù„Ø¨Ø¯Ø¡ Ù…Ù† Ø¬Ø¯ÙŠØ¯.`;
        } else {
            const listItems = folderStudentsInPlay.map(name => `<span>${name}</span>`).join(' â€¢ ');
            displayElement.innerHTML = `**Ø§Ù„Ù…ØªØ¨Ù‚ÙˆÙ† (${folderStudentsInPlay.length.toLocaleString(ARABIC_LOCALE)}):** ${listItems}`;
        }
    }

    // ----------------------------------------------------------------
    // --- Ø¯ÙˆØ§Ù„ ØªÙˆÙ„ÙŠØ¯ Ø§Ù„Ø£Ø±Ù‚Ø§Ù… ÙˆØ§Ù„Ø£Ø³Ø¦Ù„Ø© ---
    // ----------------------------------------------------------------

    function generateNumberWithRange(min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    function generateNumberWithDigits(digits, allowDecimals = 0) {
        let number;
        if (digits === 1) { 
             number = Math.floor(Math.random() * 9) + 1;
        } else if (digits > 1) {
             const min = Math.pow(10, digits - 1);
             const max = Math.pow(10, digits) - 1;
             number = Math.floor(Math.random() * (max - min + 1)) + min;
        } else { 
             number = 0; 
        }
        
        if (allowDecimals > 0) {
            const decimalPart = Math.random();
            number = number + decimalPart;
            number = parseFloat(number.toFixed(Math.max(allowDecimals + 4, 10))); 
        }
        return number;
    }

    function getNumberBounds(level, op) {
        level = parseInt(level);
        const d = (digits, decimals = 0) => ({ d: digits, dec: decimals });
        
        const dec = 0; 

        if (op === '+' || op === '-') {
            if (level === 1) return { n1: d(1, dec), n2: d(1, dec) }; 
            if (level === 2) return { n1: d(2, dec), n2: d(2, dec) }; 
            if (level === 3) return { n1: d(3, dec), n2: d(3, dec) }; 
            if (level === 4) return { n1: d(4, dec), n2: d(4, dec) }; 
            if (level === 5) return { n1: d(5, dec), n2: d(5, dec) }; 
            return { n1: d(1, dec), n2: d(1, dec) }; 
        } 
        
        if (op === '*' || op === '/') {
             if (level === 1) return { n1: { min: 1, max: 10 }, n2: { min: 1, max: 3 } }; 
             if (level === 2) return { n1: { min: 1, max: 10 }, n2: { min: 4, max: 6 } }; 
             if (level === 3) return { n1: { min: 1, max: 10 }, n2: { min: 7, max: 10 } }; 
             
             // ğŸŒŸ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø±Ø§Ø¨Ø¹ ÙˆØ§Ù„Ø®Ø§Ù…Ø³ Ù„Ø¹Ù…Ù„ÙŠØ© Ø§Ù„Ù‚Ø³Ù…Ø© ÙÙ‚Ø·
             if (op === '/') {
                if (level === 4) return { 
                    n1: { min: 100, max: 9999 }, // Ø§Ù„Ù…Ù‚Ø³ÙˆÙ… ÙƒØ¨ÙŠØ± (3-4 Ø£Ø±Ù‚Ø§Ù…)
                    n2: { min: 2, max: 9 }      // Ø§Ù„Ù…Ù‚Ø³ÙˆÙ… Ø¹Ù„ÙŠÙ‡ Ø±Ù‚Ù… ÙˆØ§Ø­Ø¯ ÙÙ‚Ø·
                }; 
                
                if (level === 5) return { 
                    n1: { min: 1000, max: 99999 }, // Ø§Ù„Ù…Ù‚Ø³ÙˆÙ… Ø£ÙƒØ¨Ø± (4-5 Ø£Ø±Ù‚Ø§Ù…)
                    n2: { min: 2, max: 9 }       // Ø§Ù„Ù…Ù‚Ø³ÙˆÙ… Ø¹Ù„ÙŠÙ‡ Ø±Ù‚Ù… ÙˆØ§Ø­Ø¯ ÙÙ‚Ø·
                };
             }
             
             // Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ø¹Ù…Ù„ÙŠØ© Ø¶Ø±Ø¨ØŒ ØªØ¨Ù‚Ù‰ ÙƒÙ…Ø§ ÙƒØ§Ù†Øª (Ø¶Ø±Ø¨ Ø¹Ù„Ù‰ Ø±Ù‚Ù…ÙŠÙ†)
             if (level === 4) return { 
                 n1: { min: 10, max: 9999 }, 
                 n2: { min: 2, max: 9 } 
             }; 
             
             if (level === 5) return { 
                 n1: { min: 10, max: 9999 }, 
                 n2: { min: 10, max: 99 }
             };
        }
        
        return { n1: d(1), n2: d(1) }; 
    }

    function generateOperationQuestion(level, op) {
        const bounds = getNumberBounds(level, op);
        let n1, n2, result;
        level = parseInt(level);
        let maxDecimals = 0;

        if (op === '+' || op === '-') {
             const dec1 = bounds.n1.dec;
             const dec2 = bounds.n2.dec;
             maxDecimals = Math.max(dec1, dec2); 
             
             n1 = generateNumberWithDigits(bounds.n1.d, dec1);
             n2 = generateNumberWithDigits(bounds.n2.d, dec2);

             if (op === '+') {
                result = n1 + n2;
             } else if (op === '-') {
                while (n2 >= n1 || n2 === 0) { 
                    n2 = generateNumberWithDigits(bounds.n2.d, dec2);
                    if (n1 <= 1) n1 = generateNumberWithDigits(bounds.n1.d, dec1); 
                }
                
                result = n1 - n2;
             }
             
             result = parseFloat(result.toFixed(maxDecimals)); 
             return { n1, n2, result, requiredDecimals: maxDecimals, isRounding: false, op: op };
        }
        
        if (op === '*' || op === '/') {
             let factor1, factor2, product;

             factor1 = generateNumberWithRange(bounds.n1.min, bounds.n1.max);
             factor2 = generateNumberWithRange(bounds.n2.min, bounds.n2.max);
             product = factor1 * factor2;
             
             if (level >= 1 && level <= 3) {
                 if (factor1 < factor2) [factor1, factor2] = [factor2, factor1];
             }
             
             if (op === '*') {
                 n1 = factor1;
                 n2 = factor2;
                 result = product;
             } else if (op === '/') {
                 n1 = product; 
                 n2 = factor2; 
                 result = factor1; 
             }
             
             return { n1, n2, result, requiredDecimals: 0, isRounding: false, op: op };
        }
        
        return { n1: 1, n2: 1, result: 2, requiredDecimals: 0, isRounding: false, op: op };
    }
    
    // ğŸŒŸ ÙˆØ¸ÙŠÙØ© Ù…Ø³Ø§Ø¹Ø¯Ø© Ù„Ø­Ø³Ø§Ø¨ Ø§Ù„ØªÙ‚Ø±ÙŠØ¨ (ØªÙ… Ø§Ù„ØªØ¹Ø¯ÙŠÙ„ Ù‡Ù†Ø§)
    function calculateRounding(number, place) {
        const places = {
            'Ø£Ù‚Ø±Ø¨ Ø¹Ø´Ø±Ø©': { value: 10, decimals: 0 },
            'Ø£Ù‚Ø±Ø¨ Ù…Ø¦Ø©': { value: 100, decimals: 0 },
            'Ø£Ù‚Ø±Ø¨ Ø£Ù„Ù': { value: 1000, decimals: 0 },
            'Ø£Ù‚Ø±Ø¨ Ø¹Ø´Ø±Ø© Ø¢Ù„Ø§Ù': { value: 10000, decimals: 0 },
            'Ø£Ù‚Ø±Ø¨ Ù…Ø¦Ø© Ø£Ù„Ù': { value: 100000, decimals: 0 },
            'Ø£Ù‚Ø±Ø¨ Ù…Ù„ÙŠÙˆÙ†': { value: 1000000, decimals: 0 },
            'Ø¬Ø²Ø¡ Ù…Ù† Ø¹Ø´Ø±Ø©': { value: 0.1, decimals: 1 },
            'Ø¬Ø²Ø¡ Ù…Ù† Ù…Ø¦Ø©': { value: 0.01, decimals: 2 },
            'Ø¬Ø²Ø¡ Ù…Ù† Ø£Ù„Ù': { value: 0.001, decimals: 3 }
        };

        const { value, decimals } = places[place] || { value: 1, decimals: 0 };

        if (value >= 1) { // ØªÙ‚Ø±ÙŠØ¨ Ø§Ù„Ø£Ø¹Ø¯Ø§Ø¯ Ø§Ù„ØµØ­ÙŠØ­Ø©
            const roundingFactor = value;
            const result = Math.round(number / roundingFactor) * roundingFactor;
            return { result, decimals };
        } else { // ØªÙ‚Ø±ÙŠØ¨ Ø§Ù„Ø£Ø¬Ø²Ø§Ø¡ Ø§Ù„Ø¹Ø´Ø±ÙŠØ© (ØªÙ… Ø§Ù„ØªØ¹Ø¯ÙŠÙ„ Ù„Ø¶Ù…Ø§Ù† Ø§Ù„ØªÙ‚Ø±ÙŠØ¨ Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠ)
            const powerOfTen = Math.pow(10, decimals);
            
            // ğŸ’¡ Ø§Ù„Ø­Ù„: Ù†Ø³ØªØ®Ø¯Ù… Math.round / powerOfTen Ù…Ø¨Ø§Ø´Ø±Ø©
            // Ù„ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„ØªÙ‚Ø±ÙŠØ¨ Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠ Ø§Ù„ØµØ­ÙŠØ­ ÙˆØªØ¬Ù†Ø¨ Ù…Ø´Ø§ÙƒÙ„ toFixed()
            const result = Math.round(number * powerOfTen) / powerOfTen;
            
            return { result: result, decimals };
        }
    }

    function generateRoundingQuestion(level) {
        let numberToRound;
        let roundingPlaceKey;
        let finalDecimalPlaces = 0;
        let decimalPlacesToGenerate = 0; 
        level = parseInt(level);

        const wholePlaces = ['Ø£Ù‚Ø±Ø¨ Ø¹Ø´Ø±Ø©', 'Ø£Ù‚Ø±Ø¨ Ù…Ø¦Ø©', 'Ø£Ù‚Ø±Ø¨ Ø£Ù„Ù', 'Ø£Ù‚Ø±Ø¨ Ø¹Ø´Ø±Ø© Ø¢Ù„Ø§Ù', 'Ø£Ù‚Ø±Ø¨ Ù…Ø¦Ø© Ø£Ù„Ù', 'Ø£Ù‚Ø±Ø¨ Ù…Ù„ÙŠÙˆÙ†'];
        const decimalPlacesList = ['Ø¬Ø²Ø¡ Ù…Ù† Ø¹Ø´Ø±Ø©', 'Ø¬Ø²Ø¡ Ù…Ù† Ù…Ø¦Ø©', 'Ø¬Ø²Ø¡ Ù…Ù† Ø£Ù„Ù'];
        
        if (level === 1) {
            roundingPlaceKey = 'Ø£Ù‚Ø±Ø¨ Ø¹Ø´Ø±Ø©';
            numberToRound = generateNumberWithRange(10, 99999); 
            decimalPlacesToGenerate = 0;
        
        } else if (level === 2) {
            const options = ['Ø£Ù‚Ø±Ø¨ Ù…Ø¦Ø©', 'Ø£Ù‚Ø±Ø¨ Ø£Ù„Ù'];
            roundingPlaceKey = options[Math.floor(Math.random() * options.length)];
            numberToRound = generateNumberWithRange(100, 999999);
            decimalPlacesToGenerate = 0;
            
        } else if (level === 3) {
            const options = { 'Ø¬Ø²Ø¡ Ù…Ù† Ø¹Ø´Ø±Ø©': 1, 'Ø¬Ø²Ø¡ Ù…Ù† Ù…Ø¦Ø©': 2 };
            const keys = Object.keys(options);
            roundingPlaceKey = keys[Math.floor(Math.random() * keys.length)];
            finalDecimalPlaces = options[roundingPlaceKey];
            
            decimalPlacesToGenerate = finalDecimalPlaces + 1 + Math.floor(Math.random() * 2); 
            const wholeDigits = generateNumberWithRange(1, 2); 
            numberToRound = generateNumberWithDigits(wholeDigits, decimalPlacesToGenerate); 
            
        } else { // level 4 & 5
            const wholeOptions = ['Ø£Ù‚Ø±Ø¨ Ø£Ù„Ù', 'Ø£Ù‚Ø±Ø¨ Ø¹Ø´Ø±Ø© Ø¢Ù„Ø§Ù', 'Ø£Ù‚Ø±Ø¨ Ù…Ø¦Ø© Ø£Ù„Ù'];
            const randomPlace = wholeOptions[Math.floor(Math.random() * wholeOptions.length)];
            
            if (Math.random() < 0.3 && level === 5) { 
                 roundingPlaceKey = 'Ø¬Ø²Ø¡ Ù…Ù† Ø£Ù„Ù';
                 finalDecimalPlaces = 3;
                 decimalPlacesToGenerate = 4 + Math.floor(Math.random() * 2);
                 const wholeDigits = generateNumberWithRange(1, 4);
                 numberToRound = generateNumberWithDigits(wholeDigits, decimalPlacesToGenerate); 
            } else { 
                 roundingPlaceKey = randomPlace;
                 let minBound = randomPlace === 'Ø£Ù‚Ø±Ø¨ Ø£Ù„Ù' ? 1000 : randomPlace === 'Ø£Ù‚Ø±Ø¨ Ø¹Ø´Ø±Ø© Ø¢Ù„Ø§Ù' ? 10000 : 100000;
                 numberToRound = generateNumberWithRange(minBound * 1.5, minBound * 10);
                 decimalPlacesToGenerate = 0;
            }
        }
        
        const { result: correctAnswerValue, decimals } = calculateRounding(numberToRound, roundingPlaceKey);
        finalDecimalPlaces = decimals;

        return {
            n1: numberToRound,
            n2: roundingPlaceKey,
            result: correctAnswerValue,
            roundingDisplayDecimals: finalDecimalPlaces,
            displayDecimalsForN1: decimalPlacesToGenerate,
            isRounding: true,
            originalRoundingPlace: roundingPlaceKey,
            op: 'R'
        };
    }
    
    function formatNumberDisplay(value, maxDecimals = 0, isRounding = false) {
        if (typeof value === 'string') return value; 
        
        // Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„ØªÙ‚Ø±ÙŠØ¨ Ù„Ø¹Ø¯Ø¯ ØµØ­ÙŠØ­ØŒ Ù†ØªØ£ÙƒØ¯ Ù…Ù† Ø¹Ø¯Ù… ÙˆØ¬ÙˆØ¯ Ù…Ù†Ø§Ø²Ù„ Ø¹Ø´Ø±ÙŠØ© ÙÙŠ Ø§Ù„Ø¹Ø±Ø¶
        if (isRounding && maxDecimals === 0) {
            return Math.round(value).toLocaleString(ARABIC_LOCALE, { useGrouping: false, maximumFractionDigits: 0 });
        }
        
        // Ø¹Ø±Ø¶ Ø§Ù„Ø£Ø±Ù‚Ø§Ù… Ø§Ù„Ø£Ø®Ø±Ù‰ Ø¨Ù…Ø§ ÙÙŠ Ø°Ù„Ùƒ Ø§Ù„Ø£Ø¬Ø²Ø§Ø¡ Ø§Ù„Ø¹Ø´Ø±ÙŠØ© Ø¨Ø¹Ø¯ Ø§Ù„ØªÙ‚Ø±ÙŠØ¨
        return value.toLocaleString(ARABIC_LOCALE, {
             useGrouping: false,
             minimumFractionDigits: maxDecimals,
             maximumFractionDigits: maxDecimals 
        });
    }

    
    function shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
        return array;
    }
    
    // ğŸŒŸ Ø¯Ø§Ù„Ø© ØªÙˆÙ„ÙŠØ¯ Ø§Ù„Ø¨Ø¯Ø§Ø¦Ù„ Ø§Ù„Ù…Ø¹Ø¯Ù„Ø© Ù„Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¹Ù…Ù„ÙŠØ§Øª
    function generateDistractors(questionData) {
        const op = questionData.op;
        const correctAnswer = questionData.result;
        const decimalPlaces = questionData.requiredDecimals || questionData.roundingDisplayDecimals || 0; 
        
        let distractors = new Set();
        let correct = parseFloat(correctAnswer.toFixed(decimalPlaces)); 
        let attempts = 0;
        
        const addDistractor = (val) => {
            val = parseFloat(val.toFixed(decimalPlaces));
            if (Math.abs(val - correct) > Math.pow(10, -(decimalPlaces + 1)) && distractors.size < 3) {
                if (correct >= 0 && val < 0) return false; 
                distractors.add(val);
                return true;
            }
            return false;
        };
        
        if (op === '+' || op === '-') {
            // ----------------------------------------------------
            // ğŸ¯ Ù…Ù†Ø·Ù‚ Ø§Ù„Ø¬Ù…Ø¹ ÙˆØ§Ù„Ø·Ø±Ø­ Ø§Ù„Ù…ÙØ­Ø³Ù‘ÙÙ† (Ø£Ø®Ø·Ø§Ø¡ Ø§Ù„Ø­Ù…Ù„ ÙˆØ§Ù„Ø§Ø³ØªÙ„Ø§Ù)
            // ----------------------------------------------------
            
            // 1. Ø®Ø·Ø£ Ù…Ù†Ø²Ù„Ø© Ø§Ù„Ø¢Ø­Ø§Ø¯ (ÙØ§Ø±Ù‚ 1)
            let smallOffset = decimalPlaces === 0 ? 1 : Math.pow(10, -decimalPlaces);
            if (addDistractor(correct + smallOffset)) {}
            if (addDistractor(correct - smallOffset)) {}
            
            // 2. Ø®Ø·Ø£ Ù…Ù†Ø²Ù„Ø© Ø§Ù„Ø¹Ø´Ø±Ø§Øª/Ø§Ù„Ø£Ø¬Ø²Ø§Ø¡ Ø§Ù„Ø¹Ø´Ø±ÙŠØ© (ÙØ§Ø±Ù‚ 10 Ø£Ùˆ 0.1)
            let mediumOffset = decimalPlaces === 0 ? 10 : Math.pow(10, -(decimalPlaces - 1));
            if (addDistractor(correct + mediumOffset)) {}
            if (addDistractor(correct - mediumOffset)) {}

            // 3. Ø®Ø·Ø£ Ù…Ù†Ø²Ù„Ø© Ø§Ù„Ù…Ø¦Ø§Øª/Ø§Ù„Ø£Ø¬Ø²Ø§Ø¡ Ø§Ù„ÙƒØ¨ÙŠØ±Ø© (ÙØ§Ø±Ù‚ 100 Ø£Ùˆ 1)
            let largeOffset = decimalPlaces === 0 ? 100 : Math.pow(10, -(decimalPlaces - 2));
             if (largeOffset < correct * 0.5) { 
                 if (distractors.size < 3) addDistractor(correct + largeOffset);
                 if (distractors.size < 3) addDistractor(correct - largeOffset);
             }

            // 4. Ù…Ù„Ø¡ Ø§Ù„ÙØ±Ø§ØºØ§Øª Ø¨Ø¨Ø¯Ø§Ø¦Ù„ Ø¹Ø´ÙˆØ§Ø¦ÙŠØ© Ù‚Ø±ÙŠØ¨Ø© (Ø¥Ø°Ø§ Ù„Ù… Ù†Ù…Ù„Ø£ 3 Ø¨Ø¹Ø¯)
            while (distractors.size < 3 && attempts < 20) {
                 let deviationFactor = (decimalPlaces > 0) ? 0.5 : 10;
                 let deviation = Math.random() * (Math.max(correct / deviationFactor, 10)) + smallOffset; 
                 let sign = Math.random() < 0.5 ? 1 : -1;
                 let potentialAnswer = correct + (sign * deviation);
                 
                 if (potentialAnswer < 0 && correct >= 0) {
                     potentialAnswer = Math.abs(potentialAnswer);
                 }
                 
                 if (addDistractor(potentialAnswer)) {}
                 attempts++;
            }
            while (distractors.size < 3) {
                 let farNumber = generateNumberWithDigits(5, decimalPlaces);
                 addDistractor(farNumber);
            }
        } else if (op === 'R') {
             // ----------------------------------------------------
             // ğŸ¯ Ù…Ù†Ø·Ù‚ Ø§Ù„ØªÙ‚Ø±ÙŠØ¨ Ø§Ù„Ù…ÙØ­Ø³Ù‘ÙÙ† ÙˆØ§Ù„Ù…Ù†Ø·Ù‚ÙŠ
             // ----------------------------------------------------
             const numberToRound = questionData.n1;
             const targetPlace = questionData.originalRoundingPlace;
             
             const placesMapping = {
                 'Ø£Ù‚Ø±Ø¨ Ø¹Ø´Ø±Ø©': { value: 10, offset: [1, 100] }, 
                 'Ø£Ù‚Ø±Ø¨ Ù…Ø¦Ø©': { value: 100, offset: [10, 1000] }, 
                 'Ø£Ù‚Ø±Ø¨ Ø£Ù„Ù': { value: 1000, offset: [100, 10000] },
                 'Ø£Ù‚Ø±Ø¨ Ø¹Ø´Ø±Ø© Ø¢Ù„Ø§Ù': { value: 10000, offset: [1000, 100000] },
                 'Ø£Ù‚Ø±Ø¨ Ù…Ø¦Ø© Ø£Ù„Ù': { value: 100000, offset: [10000, 1000000] },
                 'Ø£Ù‚Ø±Ø¨ Ù…Ù„ÙŠÙˆÙ†': { value: 1000000, offset: [100000, 10000000] },
                 'Ø¬Ø²Ø¡ Ù…Ù† Ø¹Ø´Ø±Ø©': { value: 0.1, offset: [0.01, 1] }, 
                 'Ø¬Ø²Ø¡ Ù…Ù† Ù…Ø¦Ø©': { value: 0.01, offset: [0.001, 0.1] },
                 'Ø¬Ø²Ø¡ Ù…Ù† Ø£Ù„Ù': { value: 0.001, offset: [0.0001, 0.01] }
             };
             
             const placeInfo = placesMapping[targetPlace];
             const allPlaces = Object.keys(placesMapping);
             const placeValue = placeInfo ? placeInfo.value : 1;

             if (placeInfo) {
                 
                 // 1. Ø§Ù„ØªÙ‚Ø±ÙŠØ¨ Ø¨Ø§Ù„Ø§ØªØ¬Ø§Ù‡ Ø§Ù„Ù…Ø¹Ø§ÙƒØ³ (Ø²ÙŠØ§Ø¯Ø©/Ø¥Ù†Ù‚Ø§Øµ Ø®Ø§Ø·Ø¦Ø©)
                 if (distractors.size < 3) {
                     let wrongRounding;
                     if (correct > numberToRound) {
                         wrongRounding = correct - placeValue; 
                     } else {
                         wrongRounding = correct + placeValue; 
                     }
                     if (wrongRounding > 0) addDistractor(wrongRounding); 
                 }
                 
                 // 2. Ø§Ù„ØªÙ‚Ø±ÙŠØ¨ Ø§Ù„Ø®Ø§Ø·Ø¦ Ø¥Ù„Ù‰ Ù…Ù†Ø²Ù„Ø© Ø£ØµØºØ± (Ø®Ø·Ø£ Ù…Ù†Ø²Ù„Ø© Ø´Ø§Ø¦Ø¹)
                 if (distractors.size < 3 && placeInfo.offset[0] !== 0) {
                      const offsetValue = placeInfo.offset[0];
                      // ÙŠØªÙ… ØªØ¹Ø¯ÙŠÙ„ Ù‡Ø°Ù‡ Ø§Ù„Ù†Ù‚Ø·Ø© Ù„ØªØ¨Ø­Ø« Ø¹Ù† Ø§Ø³Ù… Ø§Ù„Ù…Ù†Ø²Ù„ Ø¹Ø¨Ø± Ø§Ù„Ù‚ÙŠÙ…Ø© Ø§Ù„Ù…Ù‚Ø§Ø¨Ù„Ø© 
                      const placeName = allPlaces.find(p => {
                          const { result: calcResult } = calculateRounding(1, p);
                          return Math.abs(calcResult - offsetValue) < 0.000001;
                      });
                      if(placeName) {
                           const { result: altAnswer } = calculateRounding(numberToRound, placeName);
                           if (Math.abs(altAnswer - correct) < placeValue * 1.5) { 
                                addDistractor(altAnswer);
                           }
                      }
                 }
                 
                 // 3. Ø§Ù„ØªÙ‚Ø±ÙŠØ¨ Ø§Ù„Ø®Ø§Ø·Ø¦ Ø¥Ù„Ù‰ Ù…Ù†Ø²Ù„Ø© Ø£ÙƒØ¨Ø± (Ø£Ùˆ Ø®Ø·Ø£ Ù†Ø³ÙŠØ§Ù† Ø§Ù„ØªØµÙÙŠØ±)
                 if (distractors.size < 3 && placeValue >= 1 && numberToRound !== correct) {
                     let partToKeep = numberToRound % placeValue; 
                     if (partToKeep > 0) {
                         let mistake = correct + partToKeep;
                         if (Math.abs(mistake - numberToRound) < placeValue * 2) { 
                             addDistractor(Math.round(mistake));
                         }
                     }
                 }
             }
             
             // Ù…Ù„Ø¡ Ø§Ù„Ø®Ø§Ù†Ø§Øª Ø§Ù„Ù…ØªØ¨Ù‚ÙŠØ© Ø¨Ø£Ø±Ù‚Ø§Ù… Ù‚Ø±ÙŠØ¨Ø© (Ø¥Ø°Ø§ Ù„Ø²Ù… Ø§Ù„Ø£Ù…Ø±)
             let fallbackOffset = placeValue / 10;
             if (fallbackOffset < 1) fallbackOffset = 1;
             
             if (distractors.size < 3) addDistractor(correct + fallbackOffset);
             if (distractors.size < 3) addDistractor(correct - fallbackOffset);
             
             // Ù…Ù„Ø¡ Ø§Ù„Ø®Ø§Ù†Ø§Øª Ø§Ù„Ù…ØªØ¨Ù‚ÙŠØ© Ø¨Ø£Ø±Ù‚Ø§Ù… Ø¨Ø¹ÙŠØ¯Ø© (Ø¥Ø°Ø§ Ù„Ø²Ù… Ø§Ù„Ø£Ù…Ø±)
             while (distractors.size < 3) {
                 let farNumber = correct + (Math.random() < 0.5 ? -1 : 1) * Math.max(correct / 5, 20); 
                 if (farNumber < 0) farNumber = correct * 2;
                 addDistractor(farNumber);
             }
             
        } else if (op === '*' || op === '/') {
            // ----------------------------------------------------
            // ğŸ¯ Ù…Ù†Ø·Ù‚ Ø§Ù„Ø¶Ø±Ø¨ ÙˆØ§Ù„Ù‚Ø³Ù…Ø© Ø§Ù„Ù…ÙØ­Ø³Ù‘ÙÙ† (Ø£Ø®Ø·Ø§Ø¡ Ø§Ù„Ù…Ù†Ø²Ù„ÙŠØ© ÙˆØ§Ù„Ø¹ÙƒØ³)
            // ----------------------------------------------------
            const n1 = questionData.n1;
            const n2 = questionData.n2;
            
            // 1. Ø®Ø·Ø£ Ø§Ù„Ù…Ù†Ø²Ù„Ø© (Ø¥Ø¶Ø§ÙØ©/Ø­Ø°Ù ØµÙØ±) - ÙŠÙ†Ø·Ø¨Ù‚ Ø¹Ù„Ù‰ Ø§Ù„Ø£Ø¹Ø¯Ø§Ø¯ Ø§Ù„ØµØ­ÙŠØ­Ø© ÙÙ‚Ø·
            if (decimalPlaces === 0 && correct > 10) {
                 if (correct % 10 === 0 && correct / 10 !== 0) addDistractor(correct / 10);
                 addDistractor(correct * 10);
            }
            
            // 2. Ø§Ù„Ø®Ø·Ø£ Ø§Ù„Ø¹ÙƒØ³ÙŠ (Ø¶Ø±Ø¨ Ø¨Ø¯Ù„ Ù‚Ø³Ù…Ø©ØŒ Ø£Ùˆ Ø§Ù„Ø¹ÙƒØ³)
            if (op === '/') {
                addDistractor(n1 * n2); // Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„Ø¶Ø±Ø¨
            } else if (op === '*') {
                addDistractor(Math.round(n1 / n2)); // Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„Ù‚Ø³Ù…Ø©
            }
            
            // 3. Ø®Ø·Ø£ Ø§Ù„Ø¬Ù…Ø¹/Ø§Ù„Ø·Ø±Ø­ Ø§Ù„Ù‚Ø±ÙŠØ¨
            let smallOffset = decimalPlaces === 0 ? 1 : Math.pow(10, -decimalPlaces);
            if (distractors.size < 3) addDistractor(correct + smallOffset * generateNumberWithRange(1, 5));
            if (distractors.size < 3) addDistractor(correct - smallOffset * generateNumberWithRange(1, 5));
            
             // Ù…Ù„Ø¡ Ø§Ù„Ø®Ø§Ù†Ø§Øª Ø§Ù„Ù…ØªØ¨Ù‚ÙŠØ© Ø¨Ø£Ø±Ù‚Ø§Ù… Ø¨Ø¹ÙŠØ¯Ø©
             while (distractors.size < 3) {
                 let farNumber = correct + (Math.random() < 0.5 ? -1 : 1) * Math.max(correct / 2, 50); 
                 if (farNumber < 0) farNumber = correct + 100;
                 addDistractor(farNumber);
             }

        }
        
        return Array.from(distractors).slice(0, 3).map(d => formatNumberDisplay(d, decimalPlaces));
    }

    // ----------------------------------------------------------------
    // --- Ø¯ÙˆØ§Ù„ Ø§Ù„Ø­ÙØ¸ ÙˆØ§Ù„ØªØ­Ù…ÙŠÙ„ (Ø¨Ø§Ù‚ÙŠ Ø§Ù„Ø¯ÙˆØ§Ù„ Ø¨Ø¯ÙˆÙ† ØªØºÙŠÙŠØ±) ---
    // ----------------------------------------------------------------

    function saveContestantsData() {
         try {
            localStorage.setItem('mathHeroesNamesData', JSON.stringify(allStudentsByFolder));
        } catch (e) {
            console.error("Could not save names data to localStorage", e);
        }
    }

    function saveGlobalScores() {
        try {
            localStorage.setItem('mathHeroesGlobalScores', JSON.stringify(globalScores));
            localStorage.setItem('mathHeroesFolderNames', JSON.stringify(folderNames));
            saveContestantsData(); 
        } catch (e) {
            console.error("Could not save scores/data to localStorage", e);
        }
    }

    function loadContestantsAndScores() {
        try {
            const savedScores = localStorage.getItem('mathHeroesGlobalScores');
            if (savedScores) {
                globalScores = JSON.parse(savedScores);
            } else {
                globalScores = {};
            }

            const savedFolderNames = localStorage.getItem('mathHeroesFolderNames');
            if (savedFolderNames) {
                const loadedNames = JSON.parse(savedFolderNames);
                folderNames = loadedNames;
                document.getElementById('folder-a-name-input').value = folderNames.A;
                document.getElementById('folder-b-name-input').value = folderNames.B;
                document.getElementById('folder-c-name-input').value = folderNames.C;
            }
            
            const savedNamesData = localStorage.getItem('mathHeroesNamesData');
            if (savedNamesData) {
                allStudentsByFolder = JSON.parse(savedNamesData);
            } else {
                allStudentsByFolder = { A: [], B: [], C: [] };
            }
            
            renderContestantsList('A');
            renderContestantsList('B');
            renderContestantsList('C');

        } catch (e) {
            console.error("Could not load scores/data from localStorage", e);
            globalScores = {}; 
            allStudentsByFolder = { A: [], B: [], C: [] };
        }
    }

    // ----------------------------------------------------------------
    // --- Ø¯ÙˆØ§Ù„ Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù„Ø¹Ø¨Ø© (Ø¨Ø§Ù‚ÙŠ Ø§Ù„Ø¯ÙˆØ§Ù„ Ø¨Ø¯ÙˆÙ† ØªØºÙŠÙŠØ±) ---
    // ----------------------------------------------------------------

    function clearTimer() {
        clearInterval(timerInterval);
        document.getElementById('timer-display').style.color = '#333';
    }

    function handleTimeUp() {
        clearTimer();
        isProcessing = true; 
        
        document.querySelectorAll('.answer-btn').forEach(btn => btn.disabled = true);
        
        const feedbackElement = document.getElementById('feedback');
        feedbackElement.innerHTML = `<span class="wrong">Ø§Ù†ØªÙ‡Ù‰ Ø§Ù„ÙˆÙ‚Øª! (ØµÙØ± ÙÙˆØ² Ù„Ù€ ${currentPlayer === 1 ? playerName1 : playerName2}). Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„ØµØ­ÙŠØ­Ø© Ù‡ÙŠ: ${correctAnswerDisplay}</span>`;
        
        eliminationQuestionsCount += 1; 
        
        currentPlayer = (currentPlayer === 1) ? 2 : 1; 
        
        document.getElementById('score1-display').innerHTML = `${playerName1} (ÙÙˆØ²): ${player1Wins.toLocaleString(ARABIC_LOCALE)}`;
        document.getElementById('score2-display').innerHTML = `${playerName2} (ÙÙˆØ²): ${player2Wins.toLocaleString(ARABIC_LOCALE)}`;

        if (isTieBreaker && eliminationQuestionsCount >= 2) {
           processEliminationRoundEnd();
           return;
        }
        if (!isTieBreaker && eliminationQuestionsCount >= MAX_ELIMINATION_QUESTIONS) {
           processEliminationRoundEnd();
           return;
        }

        setTimeout(generateQuestion, 2500); 
    }

    function startTimer(duration) {
        clearTimer(); 
        timeRemaining = duration;
        const timerDisplay = document.getElementById('timer-display');
        timerDisplay.innerHTML = `${timeRemaining.toLocaleString(ARABIC_LOCALE)} Ø«ÙˆØ§Ù†Ù`;

        timerInterval = setInterval(() => {
            timeRemaining -= 1;
            timerDisplay.innerHTML = `${timeRemaining.toLocaleString(ARABIC_LOCALE)} Ø«ÙˆØ§Ù†Ù`;

            if (timeRemaining <= 5) { 
                timerDisplay.style.color = 'red';
            } else {
                timerDisplay.style.color = '#333';
            }

            if (timeRemaining <= 0) {
                handleTimeUp();
            }
        }, 1000); 
    }
    
    function selectRandomPlayers(folderKey) {
        let students;
        
        if (folderStudentsInPlay.length <= 1) { 
             folderStudentsInPlay = allStudentsByFolder[folderKey]
                .filter(c => c.selected)
                .map(c => c.name);
        }
        students = folderStudentsInPlay;

        if (students.length < 2) return null;

        const availableStudents = [...students];
         
        const index1 = Math.floor(Math.random() * availableStudents.length);
        const player1 = availableStudents[index1];
         
        availableStudents.splice(index1, 1);
         
        const index2 = Math.floor(Math.random() * availableStudents.length);
        const player2 = availableStudents[index2];
         
        return [player1, player2];
    }
    
    function finishEliminationRound(winnerName, loserName) {
        document.getElementById('feedback').innerHTML = `<span class="correct">Ø§Ù†ØªÙ‡Øª Ø§Ù„Ø¬ÙˆÙ„Ø©: ${winnerName} ÙŠÙÙˆØ²!</span> - <span class="wrong">${loserName} ÙŠØ®Ø±Ø¬ Ù…Ù† Ø§Ù„Ù…Ù†Ø§ÙØ³Ø©.</span>`;
        
        folderStudentsInPlay = folderStudentsInPlay.filter(name => name !== loserName);
        
        eliminationQuestionsCount = 0;
        player1Wins = 0;
        player2Wins = 0;
        isTieBreaker = false;
        fixedOperation = ''; 
        tournamentSchedule = []; 
        currentTournamentRound = 0;
        
        if (folderStudentsInPlay.length === 1) {
             const champion = folderStudentsInPlay[0];
             document.getElementById('feedback').innerHTML = `<h1>ğŸ† Ø§Ù„Ø¨Ø·Ù„ Ù‡Ùˆ: ${champion}! ğŸ†</h1>`;
             globalScores[champion] = (globalScores[champion] || 0) + 1; 
             saveGlobalScores();
             document.getElementById('next-round-btn').textContent = 'Ø¨Ø¯Ø¡ Ø¨Ø·ÙˆÙ„Ø© Ø¬Ø¯ÙŠØ¯Ø©';
             document.getElementById('next-round-btn').style.display = 'block';
             document.querySelectorAll('.answer-btn').forEach(btn => btn.disabled = true);
        } else {
             document.getElementById('next-round-btn').style.display = 'block';
             document.getElementById('next-round-btn').textContent = 'Ø¬ÙˆÙ„Ø© Ø¥Ù‚ØµØ§Ø¡ Ø¬Ø¯ÙŠØ¯Ø©';
        }
        
        updateRemainingContestantsDisplay();
    }
    
    function setupTournamentSchedule() {
        tournamentSchedule = [];
        let availableOps = shuffleArray([...ALL_OPERATIONS]);

        let modeMaxLevel = MAX_LEVEL; 
        const mode = document.getElementById('mode-select').value;
        
        if (mode === 'elimination4') { 
             modeMaxLevel = 3;
        } else if (mode === 'elimination5') { 
             modeMaxLevel = 4;
        }
        
        for (let i = 1; i <= modeMaxLevel; i++) {
            const op = availableOps.pop() || shuffleArray([...ALL_OPERATIONS]).pop(); 
            tournamentSchedule.push({ level: i, operation: op });
        }

        const remainingOps = availableOps; 
        remainingOps.forEach(op => {
             tournamentSchedule.push({ level: modeMaxLevel, operation: op });
        });
        
        let cycleOps = shuffleArray([...ALL_OPERATIONS]);
        while (tournamentSchedule.length < 10) { 
            const op = cycleOps.pop();
            tournamentSchedule.push({ level: modeMaxLevel, operation: op });
            if (cycleOps.length === 0) {
                 cycleOps = shuffleArray([...ALL_OPERATIONS]); 
            }
        }
        
        currentTournamentRound = 0; 
    }
    
    function processEliminationRoundEnd() {
        
        if (player1Wins === player2Wins) {
            
            if (currentMode === 'elimination2' || currentMode === 'elimination3' || currentMode === 'elimination4' || currentMode === 'elimination5') {
                 currentTournamentRound += 1;
                 
                 let newLevel, opName;
                 
                 if (currentMode === 'elimination2') {
                     newLevel = Math.min(currentTournamentRound + 1, MAX_LEVEL);
                     opName = fixedOperation === 'R' ? 'ØªÙ‚Ø±ÙŠØ¨' : fixedOperation;
                 } else { 
                      const nextRound = tournamentSchedule[Math.min(currentTournamentRound, tournamentSchedule.length - 1)];
                      newLevel = nextRound.level;
                      opName = nextRound.operation === 'R' ? 'ØªÙ‚Ø±ÙŠØ¨' : nextRound.operation;
                 }
                 
                 const statusMsg = `<span class="wrong">ØªØ¹Ø§Ø¯Ù„! ØªØ±Ù‚ÙŠØ© Ø¥Ù„Ù‰ Ø§Ù„Ù…Ø³ØªÙˆÙ‰ ${newLevel.toLocaleString(ARABIC_LOCALE)} ÙˆØ§Ù„Ø¹Ù…Ù„ÙŠØ©: ${opName}</span>`;
                 document.getElementById('feedback').innerHTML = statusMsg;
            } else { 
                document.getElementById('feedback').innerHTML = `<span class="wrong">ØªØ¹Ø§Ø¯Ù„! Ø³Ø¤Ø§Ù„ ÙØ§ØµÙ„ Ø¥Ø¶Ø§ÙÙŠ (Ù„ÙƒÙ„ Ù…ØªØ³Ø§Ø¨Ù‚)...</span>`;
            }
            
            isTieBreaker = true; 
            
            eliminationQuestionsCount = 0; 
            currentPlayer = 1; 
            
            setTimeout(generateQuestion, 2500);
            return; 
        }
        
        if (player1Wins !== player2Wins) {
            const winner = player1Wins > player2Wins ? playerName1 : playerName2;
            const loser = player1Wins > player2Wins ? playerName2 : playerName1;
            finishEliminationRound(winner, loser);
            return;
        }
    }

    function startNewRound() {
        if (!gameStarted) {
             alert('ÙŠØ±Ø¬Ù‰ Ø¨Ø¯Ø¡ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø© Ø£ÙˆÙ„Ø§Ù‹ Ù„ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø£Ø³Ù…Ø§Ø¡.');
             return;
        }
        
        currentFolderKey = document.getElementById('folder-select').value;
        currentMode = document.getElementById('mode-select').value;
        const selectedFolderName = folderNames[currentFolderKey];
        
        if (folderStudentsInPlay.length <= 1) { 
             folderStudentsInPlay = allStudentsByFolder[currentFolderKey]
                .filter(c => c.selected)
                .map(c => c.name);

             if (folderStudentsInPlay.length < 2) {
                 alert(`ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ù„Ø¯ÙŠÙƒ Ù…ØªØ³Ø§Ø¨Ù‚Ø§Ù† Ø¹Ù„Ù‰ Ø§Ù„Ø£Ù‚Ù„ ØªÙ… Ø§Ø®ØªÙŠØ§Ø±Ù‡Ù…Ø§ ÙÙŠ ${selectedFolderName} Ù„Ø¨Ø¯Ø¡ Ø¨Ø·ÙˆÙ„Ø© Ø§Ù„Ø¥Ù‚ØµØ§Ø¡.`);
                 document.getElementById('next-round-btn').textContent = 'Ø¬ÙˆÙ„Ø© Ø¬Ø¯ÙŠØ¯Ø©';
                 document.getElementById('next-round-btn').style.display = 'block';
                 updateRemainingContestantsDisplay(); 
                 return;
             }
        }

        const selectedPlayers = selectRandomPlayers(currentFolderKey);
        
        if (!selectedPlayers) {
            const count = allStudentsByFolder[currentFolderKey].filter(c => c.selected).length;
            document.getElementById('q-num1').textContent = `ØªØ£ÙƒØ¯ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø§Ø³Ù…ÙŠÙ† Ø¹Ù„Ù‰ Ø§Ù„Ø£Ù‚Ù„ ØªÙ… Ø§Ø®ØªÙŠØ§Ø±Ù‡Ù…Ø§ ÙÙŠ ${selectedFolderName}. (${count.toLocaleString(ARABIC_LOCALE)} Ù…ØªØ³Ø§Ø¨Ù‚ÙŠÙ† Ø­Ø§Ù„ÙŠÙ‹Ø§)`;
            document.getElementById('q-num2').textContent = '';
            document.getElementById('q-op2').textContent = '';
            document.getElementById('next-round-btn').style.display = 'block'; 
            document.getElementById('next-round-btn').textContent = 'Ø¬ÙˆÙ„Ø© Ø¬Ø¯ÙŠØ¯Ø©';
            updateRemainingContestantsDisplay();
            return;
        }

        playerName1 = selectedPlayers[0];
        playerName2 = selectedPlayers[1];
        
        player1Wins = 0;
        player2Wins = 0;
        eliminationQuestionsCount = 0;
        isTieBreaker = false;
        currentTournamentRound = 0; 
        
        let modeDisplay = document.getElementById('mode-select').options[document.getElementById('mode-select').selectedIndex].text;
        
        if (currentMode === 'elimination2') {
             fixedOperation = document.getElementById('operation-select').value;
             document.getElementById('feedback').innerHTML = `Ø§Ù„Ø¢Ù† ÙŠØªÙ†Ø§ÙØ³: ${playerName1} vs ${playerName2} Ù…Ù† ${selectedFolderName} (${modeDisplay} - Ø§Ù„Ø¹Ù…Ù„ÙŠØ© Ø§Ù„Ø«Ø§Ø¨ØªØ©: ${fixedOperation === 'R' ? 'ØªÙ‚Ø±ÙŠØ¨' : fixedOperation})`;
        } else if (currentMode === 'elimination3' || currentMode === 'elimination4' || currentMode === 'elimination5') {
             setupTournamentSchedule(); 
             document.getElementById('feedback').innerHTML = `Ø§Ù„Ø¢Ù† ÙŠØªÙ†Ø§ÙØ³: ${playerName1} vs ${playerName2} Ù…Ù† ${selectedFolderName} (${modeDisplay})`;
        } else { // elimination1
             document.getElementById('feedback').innerHTML = `Ø§Ù„Ø¢Ù† ÙŠØªÙ†Ø§ÙØ³: ${playerName1} vs ${playerName2} Ù…Ù† ${selectedFolderName} (${modeDisplay})`;
        }

        document.getElementById('score1-display').innerHTML = `${playerName1} (ÙÙˆØ²): ${player1Wins.toLocaleString(ARABIC_LOCALE)}`;
        document.getElementById('score2-display').innerHTML = `${playerName2} (ÙÙˆØ²): ${player2Wins.toLocaleString(ARABIC_LOCALE)}`;

        document.getElementById('next-round-btn').style.display = 'none'; 
        
        currentPlayer = 1;
        document.getElementById('answer-options-container').innerHTML = ''; 
        
        updateRemainingContestantsDisplay(); 

        setTimeout(generateQuestion, 2000); 
    }

    function startGame() {
        
        folderNames.A = document.getElementById('folder-a-name-input').value.trim() || "Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø© Ø£";
        folderNames.B = document.getElementById('folder-b-name-input').value.trim() || "Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø© Ø¨";
        folderNames.C = document.getElementById('folder-c-name-input').value.trim() || "Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø© Ø¬";
        
        saveGlobalScores(); 

        currentFolderKey = document.getElementById('folder-select').value;
        
        const selectedContestants = allStudentsByFolder[currentFolderKey]
            .filter(c => c.selected)
            .map(c => c.name); 

        if (selectedContestants.length < 2) {
             alert(`ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ù„Ø¯ÙŠÙƒ Ù…ØªØ³Ø§Ø¨Ù‚Ø§Ù† Ø¹Ù„Ù‰ Ø§Ù„Ø£Ù‚Ù„ ØªÙ… Ø§Ø®ØªÙŠØ§Ø±Ù‡Ù…Ø§ (ÙˆØ¶Ø¹ Ø¹Ù„Ø§Ù…Ø© ØµØ­) ÙÙŠ ${folderNames[currentFolderKey]} Ù„Ø¨Ø¯Ø¡ Ø§Ù„Ù…Ø³Ø§Ø¨Ù‚Ø©.`);
             return;
        }

        gameStarted = true;
        document.getElementById('start-btn').textContent = 'Ø¥Ø¹Ø§Ø¯Ø© ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø£Ø³Ù…Ø§Ø¡ ÙˆØ§Ù„Ø¨Ø¯Ø¡';
        document.getElementById('next-round-btn').style.display = 'block'; 
        document.getElementById('next-round-btn').textContent = 'Ø¬ÙˆÙ„Ø© Ø¥Ù‚ØµØ§Ø¡ Ø¬Ø¯ÙŠØ¯Ø©';
        document.getElementById('names-section').style.opacity = 0.5; 
        
        folderStudentsInPlay = selectedContestants;
        
        document.getElementById('feedback').innerHTML = `ØªÙ… ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø£Ø³Ù…Ø§Ø¡ (**${selectedContestants.length.toLocaleString(ARABIC_LOCALE)}** Ù…ØªØ³Ø§Ø¨Ù‚ÙŠÙ† ØªÙ… Ø§Ø®ØªÙŠØ§Ø±Ù‡Ù…). Ø§Ø¶ØºØ· "Ø¬ÙˆÙ„Ø© Ø¥Ù‚ØµØ§Ø¡ Ø¬Ø¯ÙŠØ¯Ø©" Ù„Ù„Ø¨Ø¯Ø¡ Ø¨ÙŠÙ† Ù…ØªØ³Ø§Ø¨Ù‚ÙŠÙ† Ø¹Ø´ÙˆØ§Ø¦ÙŠÙŠÙ† Ù…Ù† ${folderNames[currentFolderKey]}.`;
        document.getElementById('q-num1').textContent = 'Ø¬Ø§Ù‡Ø²ÙˆÙ† Ù„Ù„Ø§Ù†Ø·Ù„Ø§Ù‚!';
        document.getElementById('q-num2').textContent = '';
        document.getElementById('q-op2').textContent = '';
        document.getElementById('answer-options-container').innerHTML = ''; 
        
        updateRemainingContestantsDisplay();
    }
    
    function generateQuestion() {
        if (!gameStarted) return;
        
        clearTimer();
        isProcessing = false;
        document.getElementById('feedback').innerHTML = '';
        document.getElementById('answer-options-container').innerHTML = ''; 
        
        let op, level;
        
        if (currentMode === 'elimination3' || currentMode === 'elimination4' || currentMode === 'elimination5') {
             const roundInfo = tournamentSchedule[Math.min(currentTournamentRound, tournamentSchedule.length - 1)];
             op = roundInfo.operation;
             level = roundInfo.level;
             
             const opName = op === 'R' ? 'ØªÙ‚Ø±ÙŠØ¨' : op;
             const currentPlayerName = currentPlayer === 1 ? playerName1 : playerName2;
             document.getElementById('feedback').innerHTML = `Ø§Ù„Ø¯ÙˆØ± Ù„Ù€ **${currentPlayerName}** - ğŸ¯ Ø§Ù„Ù‡Ø¯Ù: Ø§Ù„Ù…Ø³ØªÙˆÙ‰ ${level.toLocaleString(ARABIC_LOCALE)} (${opName})`;
             
        } else if (currentMode === 'elimination2') {
             op = fixedOperation;
             level = Math.min(currentTournamentRound + 1, MAX_LEVEL); 
             const opName = op === 'R' ? 'ØªÙ‚Ø±ÙŠØ¨' : op;
             const currentPlayerName = currentPlayer === 1 ? playerName1 : playerName2;
             document.getElementById('feedback').innerHTML = `Ø§Ù„Ø¯ÙˆØ± Ù„Ù€ **${currentPlayerName}** - ğŸ¯ Ø§Ù„Ù‡Ø¯Ù: Ø§Ù„Ù…Ø³ØªÙˆÙ‰ ${level.toLocaleString(ARABIC_LOCALE)} (${opName})`;
             
        } else { 
             op = document.getElementById('operation-select').value;
             level = document.getElementById('level-select').value;
        }

        let questionData;
        let decimalsToDisplay = 0; 
        let n1DisplayDecimals = 0; 
        let isRoundingQuestion = false;

        if (op === 'R') {
             questionData = generateRoundingQuestion(level);
             decimalsToDisplay = questionData.roundingDisplayDecimals;
             currentRoundingDecimals = decimalsToDisplay; 
             n1DisplayDecimals = questionData.displayDecimalsForN1; 
             currentRoundingPlace = questionData.originalRoundingPlace;
             isRoundingQuestion = true;
        } else {
             questionData = generateOperationQuestion(level, op);
             decimalsToDisplay = questionData.requiredDecimals; 
             currentRoundingDecimals = decimalsToDisplay; 
             n1DisplayDecimals = decimalsToDisplay; 
        }
        
        num1 = questionData.n1;
        num2 = questionData.n2;
        correctAnswerValue = questionData.result;
        
        const formattedNum1 = formatNumberDisplay(num1, (op === 'R') ? n1DisplayDecimals : decimalsToDisplay, op === 'R'); 
        let formattedNum2 = '';
        let operatorDisplay = op;

        if (op === 'R') {
            operatorDisplay = 'Ù‚Ø±Ø¨ Ø¥Ù„Ù‰:';
            formattedNum2 = num2; 
        } else {
            formattedNum2 = formatNumberDisplay(num2, (op === '+' || op === '-') ? decimalsToDisplay : 0, false);
            operatorDisplay = op === '*' ? 'Ã—' : op === '/' ? 'Ã·' : op;
        }

        document.getElementById('q-num1').textContent = formattedNum1;
        document.getElementById('q-op2').textContent = operatorDisplay;
        document.getElementById('q-num2').textContent = formattedNum2;

        correctAnswerDisplay = formatNumberDisplay(correctAnswerValue, decimalsToDisplay, op === 'R' && (decimalsToDisplay === 0));
        
        const distractors = generateDistractors({
            isRounding: isRoundingQuestion,
            result: correctAnswerValue,
            requiredDecimals: decimalsToDisplay,
            n1: num1,
            n2: num2, 
            op: op, 
            originalRoundingPlace: currentRoundingPlace
        }); 
        
        let options = shuffleArray([...distractors, correctAnswerDisplay]);

        const optionsContainer = document.getElementById('answer-options-container');
        optionsContainer.innerHTML = '';
        options.forEach(option => {
            const button = document.createElement('button');
            button.className = 'answer-btn';
            button.textContent = option;
            button.onclick = () => checkAnswer(button, option);
            optionsContainer.appendChild(button);
        });
        
        const currentName = currentPlayer === 1 ? playerName1 : playerName2;
        document.getElementById('current-player').textContent = currentName;
        
        let time = TIME_LIMIT; 

        document.getElementById('timer-display').style.color = '#333';
        startTimer(time);
    }
    
    function checkAnswer(selectedButton, selectedAnswer) {
        if (isProcessing) return;
        isProcessing = true;
        clearTimer(); 
        
        const isCorrect = selectedAnswer === correctAnswerDisplay;
        const feedbackElement = document.getElementById('feedback');
        
        document.querySelectorAll('.answer-btn').forEach(btn => btn.disabled = true);
        
        if (isCorrect) {
            selectedButton.classList.add('correct-answer');
            feedbackElement.innerHTML = `<span class="correct">Ø¥Ø¬Ø§Ø¨Ø© ØµØ­ÙŠØ­Ø©! (+1 ÙÙˆØ² Ù„Ù€ ${currentPlayer === 1 ? playerName1 : playerName2})</span>`;
            
            if (currentPlayer === 1) {
                player1Wins += 1;
            } else {
                player2Wins += 1;
            }
            
        } else {
            selectedButton.classList.add('wrong-answer');
            document.querySelectorAll('.answer-btn').forEach(btn => {
                if (btn.textContent === correctAnswerDisplay) {
                    btn.classList.add('correct-answer');
                }
            });
            feedbackElement.innerHTML = `<span class="wrong">Ø¥Ø¬Ø§Ø¨Ø© Ø®Ø§Ø·Ø¦Ø©! Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„ØµØ­ÙŠØ­Ø© Ù‡ÙŠ: ${correctAnswerDisplay}</span>`;
        }

        eliminationQuestionsCount += 1; 
        
        document.getElementById('score1-display').innerHTML = `${playerName1} (ÙÙˆØ²): ${player1Wins.toLocaleString(ARABIC_LOCALE)}`;
        document.getElementById('score2-display').innerHTML = `${playerName2} (ÙÙˆØ²): ${player2Wins.toLocaleString(ARABIC_LOCALE)}`;
        
        if (isTieBreaker && eliminationQuestionsCount >= 2) {
           processEliminationRoundEnd();
           return;
        }
        if (!isTieBreaker && eliminationQuestionsCount >= MAX_ELIMINATION_QUESTIONS) {
           processEliminationRoundEnd();
           return;
        }

        currentPlayer = (currentPlayer === 1) ? 2 : 1;
        setTimeout(generateQuestion, 2500); 
    }
    
    // ----------------------------------------------------------------
    // --- Ø§Ù„ØªØ­Ù…ÙŠÙ„ Ø¹Ù†Ø¯ Ø¨Ø¯Ø¡ Ø§Ù„ØªØ´ØºÙŠÙ„ ---
    // ----------------------------------------------------------------
    window.onload = () => {
        loadContestantsAndScores();
        toggleOpLevelControls(); 
    };
    
</script>
</body>
</html>
